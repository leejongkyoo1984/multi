# メソッド
## ポインター対。値


`ByteSize`で見られるように、メソッドはポインタとインタフェースを除くすべての型に対して定義が可能である。受信機は必ずしも構造体である必要はありません。


上記のスライスについての議論で、我々はAppend関数を書いた。これをスライスのメソッドとしてオーバーライドできます。このために、このメソッドをバインドするタイプを一つ宣言しましょう。そして、メソッドから型の値を受け取るためのレシーバを作成しましょう。

```go
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // 関数の内容は、上記で定義したAppend関数とまったく同じです。
}
```

この関数はまだ更新されたスライスを返す必要があります。この手間をメソッドが `ByteSlice` へのポインタをレシーバとして受け取ることができるようにオーバーライドすることで、このメソッドはメソッドを呼び出したスライスを上書きすることができます。

```go
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // 関数の内容は上記と同じですが、returnはありません。
    *p = slice
}
```

実際、これより良い関数を書くこともできます。上記の関数を次のように標準の `Write`メソッドのように書くと

```go
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // 内容は上記の通りです。
    *p = slice
    return len(data), nil
}
```

タイプ `*ByteSlice` は標準インターフェース `io.Writer` に準拠し、扱いが楽になる。たとえば、次のように `ByteSlice`に値を入れることができます。

```go
var b ByteSlice
fmt.Fprintf(&b, "This hour has %d days\n", 7)
```

`ByteSlice`のアドレスだけを渡したのは、ポインタ型の`*ByteSlice`だけが`io.Writer`インタフェースを満たすからだ。受信者にポインタを書き込むか値を書き込むかについての規則は、値を使用するメソッドはポインタと値の両方で使用でき、ポインタメソッドの場合はポインタでのみ使用できるということです。


このようなルールは、ポインタメソッドはレシーバを変形させることができ、メソッドを値から呼び出すと値のコピーを受け取るため元の値を変形できないために生じた。 Go言語はこれらの間違い（値でポインタメソッドを実行すること）を許可しません。しかし、便利な例外もある。アドレスを取得できる値の場合、Go言語はポインタメソッドを値の上で実行すると自動的にアドレス演算を入れます。上記の例では、変数 `b`はアドレスにアクセス可能であるため、単に `b.Write`だけで `Write`メソッドを呼び出すことができます。コンパイラはこれを `(&b).Write` に書き換えます。


どうやら、バイトスライスに `Write`を使用するというアイデアは `bytes.Buffer`実装の核心でもある。
