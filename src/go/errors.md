# エラー

ライブラリルーチンは、呼び出し元に何らかの兆候のエラーがあっても頻繁に返す必要があります。前述のように、Goの多値戻りは、一般的な戻り値と比較して詳細なエラー内容を提供するのを容易にします。詳細なエラー内容を提供するためにこれらの機能を利用するのは良い方法です。例えば、今後見られる `os.Open` は失敗した場合、単に `nil` だけを返さず、何が間違っているかについてのエラー内容まで返す。

規約によれば、エラーは単純な組み込みインタフェースのエラータイプを持つ。

```go
type error interface {
    Error() string
}
```


ライブラリ開発者は見えませんが、より豊富なモデルを使用して上記のインタフェースを自由に実装しながら、エラーを示すだけでなく、どのようなコンテキストを一緒に提供することも可能です。言及したように、通常 `os.Open` は `*os.File` 値を返すと同時にエラー値も返します。ファイルが正常にオープンされた場合、エラーは `nil`になり、オープン中に問題が発生した場合は `os.PathError`の値があります:

```go
// PathErrorはエラーと演算、問題を発生させたファイルパスを持っている。
type PathError struct {
    Op string    // "open", "unlink", など.
    Path string  // 関連ファイル.
    Err error    // システムコールによって返される.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
```

`PathError`の `Error`メソッドは次のような文字列を生成します:

```go
open /etc/passwx: no such file or directory
```


上記のエラーは、問題が発生したファイル名と操作、そして問題を発生させたオペレーティングシステムエラーを持っており、これは問題を発生させたシステムコールから遠く離れたところで見せても便利です。これは単に `no such file or directory`を示すよりもはるかに多くの情報を提供します。


可能であれば、エラー文字列は、エラーが発生したコマンドやパッケージをプレフィックスとして書き込むなど、エラーの原因を特定できるはずです。たとえば、 `image`パッケージで不明なフォーマットによって発生したデコードエラーのための文字列表現は `image：unknwon format.`です。


正確な詳細エラーの内容に興味がある発信者は、詳細および追加の情報を取得するためにタイプスイッチングまたはタイプステートメントを使用できます。 `PathErrors`の場合、エラーを修復するために内部 `Err`フィールドを調べることができます。

```go
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // スペースを確保する。
        continue
    }
    return
}
```


2番目のifステートメントでは、 `err`インタフェースを `os.PathError`型に変換します（type assertion）。失敗すると `ok` は `false` になり、 `e` は `nil' になる。成功すれば `ok` は `true` になり、これはエラーが `*os.PathError` タイプであることを意味する。これで `e` でエラーに関するより多くの情報を確認することができる。

## パニック (Panic)

呼び出し元にエラーを知らせる一般的な方法は、エラーを追加値として返すことです。規範的な `Read`メソッドはよく知られた例で、これはバイト数とエラーを返します。しかし、回復できないエラーならどうなるのか？時々プログラムはもはや進行しないでしょう。


この目的のために、Goにはランタイムエラーを引き起こしてプログラムを中断させる「panic」という組み込み関数があります（しかし、次のセクションを見てください）。この関数は、プログラムが終了したときに出力される任意のタイプの1つを引数として受け取ります（通常は `string`です）。これはまた、不可能なことが起こったことを知らせる方法でもあり、無限ループから脱出することが例になり得る。

```go
// ニュートンメソッドを使用して平方根を求める実装
func CubeRoot(x float64) float64 {
    z := x/3   // 任意の初期値
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // 百万回のループを回しても収束しない。何かが間違っていた。
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
```


これは一例です。実際のライブラリ関数は `panic`を避けるべきです。もし問題が隠れていたり、周辺で問題を発生させても、実行を続けるのがプログラム全体を終了するよりも優れている。 1つの可能な反例は初期化作業中ですが、ライブラリが初期設定に失敗した場合はパニックを発生させ、通知する必要があります。

```go
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
```

## 回復 (Recover)


スライスの範囲を超えたインデックス付けやタイプの断言失敗などのランタイムエラーを含むパニックが発生した場合、これは直ちに現在の関数の実行を中断させ、すべての遅延された（deferred）関数を実行しながらゴルチンスタックを解き始める。解凍操作がゴルチンスタックの最上位に達すると、プログラムは終了します。しかし、組み込み関数である `recover` を使うとゴルチンの制御権を再び得ることができ、命令実行を正常に進めることができるようになる。



`recover`を呼び出すと、解凍操作が中止され、`panic`に渡された引数の値が返されます。解凍操作中に実行されるコードは遅延関数内でのみ実行されるため、 `recover`は遅延関数内でのみ有用です。


`recover`の1つのアプリケーションの1つは、サーバー内の実行中の他のゴルチンは殺さず、失敗したゴルチンだけを終了させることです。

```go
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```

この例では、「do（work）」でパニックが発生した場合、結果はログに残り、ゴルチンは他のゴルチンを妨げることなくきちんと終了します。呼び出された `recover`がこの状況を完全に処理するので、遅延されたクロージャでは何もする必要はありません。


`recover`は遅延関数から直接呼び出される場合を除いて常に`nil`を返すので、遅延コードは `panic'と `recover`を使用するライブラリルーチンを失敗せずに呼び出すことができる。一例を挙げると、 `safelyDo`内の遅延関数は `recover`を呼び出す前にlogging関数を呼び出すことができ、loggingコードはパニック状態に影響されずにうまく実行されるだろう。


上記の復旧パターンを見ると、 `do`関数（そして呼び出しを行うどれも）は `panic`を呼び出すことで悪い状況を避けることができる。このアイデアを活用すると、複雑なソフトウェアでのエラー処理を簡素化できます。 `regexp`パッケージの最も理想的なバージョンを見てみましょう。これは、独自のエラータイプで `panic`を呼び出すことによって解析エラーを通知します。以下に `Error` とエラーメソッド、そして `Compile` 関数の定義がある。

```go
// Errorは解析エラータイプで、errorインタフェースを満たしています。
type Error string
func (e Error) Error() string {
    return string(e)
}

// errorは、Errorのパニックで解析エラーを通知する* Regexpメソッドです。
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compileは正規表現の解析された表現を返します。
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParseは、解析中にエラーが発生するとパニックを引き起こします。
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // 戻り値クリア
            err = e.(Error) // 解析エラーでなければ再パニック
        }
    }()
    return regexp.doParse(str), nil
}
```

`doParse`がパニックを起こした場合、回復ブロックは戻り値をnilに設定します。遅延関数は名前付き戻り値を変更できます。 `err`に値を代入する過程でエラーを独自のエラータイプと断言することで、その問題が解析エラーかどうかをチェックすることになる。もし解析エラーでなければ、タイプの断言は失敗し、まるで何の中断がなかったかのようにスタック解凍作業を進め、ランタイムエラーを起こすだろう。このチェックは、インデックスが範囲外であるなど、意図しないことが発生したときに解析エラーを処理するために `panic`と `recover`を使用したにもかかわらず、コードが失敗することを意味します。


以下のエラー処理を見ると、エラーメソッドは（タイプにバインドするメソッドなので、組み込みエラータイプと同じ名前を使用するのは自然で大丈夫です）、直接解析スタックを解くことを心配することなく解析エラーを通知するのは簡単です:

```go
if pos == 0 {
    re.error("'*' illegal at start of expression")
}
```

このパターンは有用であるにもかかわらず、パッケージ内でのみ使用する必要があります。 `Parse`は内部パニック呼び出しをエラー値に置き換えます。これはクライアントにパニックを公開しません。これは見受けられる良いルールです。


確かに、 `re-panic`イディオムは実際にエラーが発生したときにパニック値を変更します。しかし、元の値と新しい失敗の両方がエラー報告に表示されるため、問題の根本的な原因も依然として見られます。したがって、（プログラムがクラッシュしたことを考えると）、これらの単純な `re-panic` アプローチが十分であると見ることができますが、元の値だけを表示したい場合は、意図しない問題をフィルタリングするコードを書くことができ、元のエラーを持って `re-panic`をすることができる。これは読者に宿題として残す。