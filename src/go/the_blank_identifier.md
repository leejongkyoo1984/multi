# スペース識別子 (The blank identifier)
私たちはすでに `for range`ループと `maps`を説明しながら、スペース識別子について2回言及しました。空白識別子は、何の損害もなく、任意の種類の値に割り当てまたは宣言できます。これは、Unixの `/dev/null` ファイル(必要はあるが実際の値は何の関係もない変数を格納する目的として使用される書き込み専用値)に値を渡すのと似ている。

## 複数の割り当てにおける空白識別子


`for range`ループでスペース識別子を使用することは、一般的な状況での特別なケース（複数割り当て）です。


左辺に余白の値を割り当てる必要があり、そのうちの1つが使用されていない場合、左辺に空白識別子を置くとダミー変数を生成する必要がなくなり、値を捨てることをきちんと処理することができる。たとえば、1つの値とエラーを返す関数を呼び出すためにエラーだけが重要である場合は、無関係な値を破棄するためにスペース識別子を使用します。

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
```

時々エラーを無視するためにエラー値を捨てるコードを見ることができます。これは非常に悪い慣行です。エラーの返却を常に確認してください。エラーが発生するには理由がある。

```go
// Bad! This code will crash if path does not exist.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
```

## 未使用のインポートと変数


パッケージをインポートしたり、変数を宣言して書き込めなくなるとエラーが発生する。未使用のインポートはプログラムのサイズを膨らませ、コンパイル速度も低下させます。また、使用されていないが初期化された変数は少なくとも操作を無駄にし、多分大きなバグを暗示するかもしれません。しかし、プログラムが開発中にあるとき、未使用のインポートと変数がしばしば発生することになり、ただコンパイルが進むようにするために後で再び必要になるこれらをクリアするのは面倒かもしれない。スペース識別子はこれを回避する方法を提供します。


以下の半分の完成したプログラムには、2つの未使用インポート（ `fmt`、 `io`）と未使用変数（ `fd`）があります。したがって、これはコンパイルされません。しかし、これまでコードが正確に作られているかどうかを知ることができれば良いでしょう。

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
}
```

未使用のインポートに関する文句を潜在的にするには、インポートされたパッケージのシンボルを参照するスペース識別子を書きます。同様に、未使用変数 `fd` を空白識別子に割り当てると、未使用変数に対するエラーが発生する可能性があります。このバージョンのプログラムはコンパイルになります。

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf // For debugging; delete when done.
var _ io.Reader    // For debugging; delete when done.

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
    _ = fd
}
```


規約によれば、インポートエラーを潜在させるためのグローバル宣言は、インポート構文の直後に置かれ、注釈を付けなければならない。彼らは後でコードを整理する必要があることを簡単に思い出させ、見つけやすくします。

## 付随効果のためのインポート


前の例では、`fmt`や`io`のような未使用のインポートは最終的に使用されるべきであるか、そうでなければ排除されるべきです。 （空白の割り当てはまだ作業が進行中のコードとして認識されなければなりません）。例えば、`net/http/pprof`パッケージは、パッケージの初期化関数の実行中にデバッグ情報を提供するHTTPハンドラを登録します。これは公開されたAPIを持っていますが、大部分のクライアントはハンドラー登録のみを必要とし、情報にはWebページを介してアクセスします。付随効果のためにこのパッケージをインポートするには、このパッケージ名を空白の識別子に変更するだけです:

```go
import _ "net/http/pprof"
```

この形式のインポートは、パッケージが付随効果のためにインポートされていることを明確にすることができます。なぜなら、このファイルではパッケージが名前を持っていないので使用される可能性がないからです。 （名前があり、それを使用しない場合、コンパイラはプログラムを拒否します。）

## インターフェース検査


上記のインタフェースについての議論で示したように、型はインタフェースを実装したことを明示的に宣言する必要はありません。代わりに、型はインタフェースのメソッドを実装することによってインタフェースを実装します。実際、大部分のインタフェース変換は静的であるため、コンパイル中に検査が行われます。例えば、もし `*os.File` が `io.Reader` インタフェースを実装していないが、それを `io.Reader` を期待する関数に引数として渡すとコンパイルされないだろう。


しかし、いくつかのインターフェイスチェックは実行時に発生します。 1つの例は、 `Marshaler`インタフェースを定義する `encoding / json`パッケージにあります。 JSONエンコーダがそのインタフェースを実装した値を受け取ると、エンコーダはJSONに変換するために標準変換を進める代わりに値の `marshiling`メソッドを実行します。エンコーダは、ランタイム時に次のようにタイプの断言をしながらプロパティを検査する。

```go
m, ok := val.(json.Marshaler)
```


型がインタフェースを実装していないかどうかを実際のインタフェース自体を使用せずに、エラーチェックの一部として確認する必要がある場合は、型が指定された値を無視するために空白識別子を使用してください:

```go
if _, ok := val.(json.Marshaler); ok {
    fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
```


このような状況が現れる場合は、パッケージが実際にインタフェースを満たすタイプを実装していることを保証する必要があるときです。もしあるタイプがカスタマイズされたJSON表記法が必要な場合(例えば、`json.RawMessage`)、これは`json.Marshaler`を実装しなければならない。しかし、コンパイラにそれを自動的に確認させる静的な変換はありません。誤って型がそのインタフェースを満たすことに失敗すると、JSONエンコーダはまだ実行されますが、カスタマイズされた実装を使用できなくなります。インタフェースの実装を保証するために、パッケージ内でスペース識別子を使用するグローバル宣言を使用できます。

```go
var _ json.Marshaler = (*RawMessage)(nil)
```

上記の宣言では、「* RawMessage」を「Marshaler」に変換する割り当てによって、「* RawMessage」に「Marshaler」を実装する必要があり、これらの属性はコンパイル時にチェックされます。もし `json.Marshaler`インタフェースに変化が生じた場合、このパッケージはもはやコンパイルされなくなり、パッケージが更新されなければならないことを知らせる。


この構造では、空白の識別子が現れることは、上記の宣言が変数を作成するのではなく、型チェックのためにのみ存在することを示しています。しかし、これを1つのインタフェースを満たすすべてのタイプに使用しないでください。規約によれば、上記のような宣言は珍しい場合であるが、すでにコードに存在する静的変換がない場合にのみ使用することである。
